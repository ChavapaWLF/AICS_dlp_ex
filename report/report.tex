% 这是实验报告的基本模板，你需要根据实验具体内容，结合实验过程中的真实感想，补充完善成一份完整的实验报告
% 无需复述实验的基本流程，鼓励多描述实验过程中遇到的困难以及解决的办法，并阐述在此基础上衍生的思考

\documentclass[11pt]{article}

\usepackage[a4paper]{geometry}
\geometry{left=2.0cm,right=2.0cm,top=2.5cm,bottom=2.5cm}

\usepackage{ctex} % 支持中文的LaTeX宏包
\usepackage{amsmath,amsfonts,graphicx,subfigure,amssymb,bm,amsthm,mathrsfs,mathtools,breqn} % 数学公式和符号的宏包集合
\usepackage{algorithm,algorithmicx} % 算法和伪代码
\usepackage[noend]{algpseudocode} % 算法和伪代码
\usepackage{fancyhdr} % 自定义页眉页脚
\usepackage[framemethod=TikZ]{mdframed} % 创建带边框的框架
\usepackage{fontspec} % 字体设置
\usepackage{adjustbox} % 调整盒子大小
\usepackage{fontsize} % 设置字体大小
\usepackage{tikz,xcolor} % 绘制图形和使用颜色
\usepackage{multicol} % 多栏排版
\usepackage{multirow} % 表格中合并单元格
\usepackage{pdfpages} % 插入PDF文件
\usepackage{listings} % 在文档中插入源代码
\usepackage{wrapfig} % 文字绕排图片
\usepackage{bigstrut,multirow,rotating} % 支持在表格中使用特殊命令
\usepackage{booktabs} % 创建美观的表格
\usepackage{circuitikz} % 绘制电路图
\usepackage{zhnumber} % 中文序号（用于标题）
\usepackage{tabularx} % 表格折行
\usepackage{float} % 图片插入

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{
  frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  framerule=1pt,
  rulecolor=\color{gray!35},
  backgroundcolor=\color{gray!5},
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}

% 轻松引用, 可以用\cref{}指令直接引用, 自动加前缀. 
% 例: 图片label为fig:1
% \cref{fig:1} => Figure.1
% \ref{fig:1}  => 1
\usepackage[capitalize]{cleveref}
% \crefname{section}{Sec.}{Secs.}
\Crefname{section}{Section}{Sections}
\Crefname{table}{Table}{Tables}
\crefname{table}{Table.}{Tabs.}

% \setmainfont{Palatino Linotype.ttf}
% \setCJKmainfont{SimHei.ttf}
% \setCJKsansfont{Songti.ttf}
% \setCJKmonofont{SimSun.ttf}
\punctstyle{kaiming}
% 偏好的几个字体, 可以根据需要自行加入字体ttf文件并调用

\renewcommand{\emph}[1]{\begin{kaishu}#1\end{kaishu}}

% 对 section 等环境的序号使用中文
\renewcommand \thesection{\zhnum{section}、}
\renewcommand \thesubsection{\arabic{subsection}}

\begin{document}
\begin{center}
  \LARGE \bf 中国科学院大学 \\《智能计算系统》实验报告
\end{center}

% 所有需要的截图已存放在fig目录下，直接引用图片即可（如fig/pic_name.png）

\section{实验内容}

本实验旨在掌握深度学习处理器中矩阵运算器的设计原理，通过使用Verilog硬件描述语言实现内积运算器、矩阵乘向量运算器、矩阵乘法运算器的设计，并通过Verilator仿真工具进行功能验证。深度学习处理器（DLP）采用矩阵运算作为基本算子，相比于传统CPU、GPU采用的标量、向量运算，具有更高的运算密度，能够在同等访存能力下达到更强的运算能力。

实验主要包含以下任务：

\begin{enumerate}
    \item \textbf{环境搭建}：在Ubuntu 22.04 LTS系统上安装配置Verilator和GTKWave仿真工具链。
    \item \textbf{内积运算器设计}：实现4元素16位有符号整数的并行内积运算，采用两级流水线结构，包含输入寄存器、4个并行乘法器和加法树。
    \item \textbf{矩阵乘向量运算器设计}：基于内积运算器，通过实例化4个内积运算单元，实现4×4权重矩阵与4元素输入神经元激活值的矩阵乘向量运算。
    \item \textbf{矩阵乘法运算器设计}：基于矩阵乘向量运算器，通过实例化4个矩阵乘向量运算单元，实现4×4矩阵与4×4矩阵的矩阵乘法运算。
    \item \textbf{功能仿真与验证}：编写C++测试文件，生成激励信号，验证三种运算器的功能正确性，并通过GTKWave观察波形进行时序分析。
    \item \textbf{测试框架完善}：设计多组测试数据，编写一键测试脚本，对三种运算器进行全面的功能验证。
\end{enumerate}

\section{实验步骤与设计分析}

\subsection{实验环境搭建}

实验基于Ubuntu 22.04 LTS操作系统，使用Verilator作为Verilog仿真器，使用GTKWave作为波形查看工具。Verilator是一款开源的Verilog/SystemVerilog仿真器和代码生成器，能够将HDL代码转换成高性能的C++库，完成数字电路的功能仿真和验证。

首先安装Verilator编译所需的依赖包：
\begin{lstlisting}[language=bash]
sudo apt-get install git help2man perl python3 make autoconf g++ flex bison ccache
sudo apt-get install libgoogle-perftools-dev numactl perl-doc
sudo apt-get install libfl2 libfl-dev zlibc zlib1g zlib1g-dev
\end{lstlisting}

然后下载并编译安装Verilator：
\begin{lstlisting}[language=bash]
git clone https://gitee.com/mirrors/Verilator.git
cd Verilator
autoconf
./configure
make -j `nproc`
sudo make install
\end{lstlisting}

最后安装GTKWave波形查看工具：
\begin{lstlisting}[language=bash]
sudo apt-get install gtkwave
\end{lstlisting}

安装完成后，可通过\texttt{verilator --version}和\texttt{gtkwave --version}命令验证安装是否成功。

\subsection{内积运算器设计}

内积运算器是深度学习处理器矩阵运算单元的基础模块，其核心功能是实现两个向量的乘积累加运算。本实验实现的内积运算器接收4个16位有符号整数的激活值和4个16位有符号整数的权重，输出32位有符号整数的内积结果。采用两级流水线结构：第一级为输入采样阶段，在时钟上升沿将输入数据锁存到寄存器；第二级为计算输出阶段，4个乘法器并行计算部分积，随后通过加法树累加得到最终结果。这种设计在保证每个时钟周期完成一次内积运算的同时，有效降低了关键路径延迟，提高了电路的最高工作频率。

使能信号（enable）控制寄存器的更新，当使能信号无效时寄存器保持原值，避免组合逻辑不必要的翻转，从而降低动态功耗。同步复位信号（reset）在高电平时将所有寄存器清零，确保电路初始状态的确定性。

\begin{lstlisting}[language=Verilog]
module inner_product_4x16 (
    input wire clk,
    input wire reset,
    input wire enable,
    input wire signed [15:0] activations [0:3],
    input wire signed [15:0] weights [0:3],
    output reg signed [31:0] result
);
    // 输入寄存器
    reg signed [15:0] activations_reg [0:3];
    reg signed [15:0] weights_reg [0:3];
    
    // 组合逻辑：并行乘法与累加
    wire signed [31:0] dot_product = 
        (activations_reg[0] * weights_reg[0]) +
        (activations_reg[1] * weights_reg[1]) +
        (activations_reg[2] * weights_reg[2]) +
        (activations_reg[3] * weights_reg[3]);
    
    // 寄存器更新逻辑
    integer i;
    always @(posedge clk) begin
        if (reset) begin
            for (i = 0; i < 4; i = i + 1) begin
                activations_reg[i] <= 16'd0;
                weights_reg[i] <= 16'd0;
            end
            result <= 32'd0;
        end else if (enable) begin
            for (i = 0; i < 4; i = i + 1) begin
                activations_reg[i] <= activations[i];
                weights_reg[i] <= weights[i];
            end
            result <= dot_product;
        end
    end
endmodule
\end{lstlisting}

在设计中，使用了\texttt{signed}关键字声明有符号数，确保乘法运算生成有符号数乘法器。

\subsection{矩阵乘向量运算器设计}

矩阵乘向量运算可以分解为多个内积运算：权重矩阵的每一行与激活值向量进行内积运算，产生输出向量的一个元素。因此，矩阵乘向量运算器通过并行实例化4个内积运算器实现。4个内积运算器共享同一个激活值向量输入（通过广播机制），分别接收权重矩阵的不同行，并行产生4个输出结果。

这种设计相比于分离的4个内积运算器具有更高的运算密度：激活值数据仅需读取一次即可参与4次内积运算，有效降低了对便笺存储器访问带宽的需求，在同等访存能力下可达到更高的算力。

\begin{lstlisting}[language=Verilog]
module matrix_vector_mult_4x4x16 (
    input wire clk,
    input wire reset,
    input wire enable,
    input wire signed [15:0] activations [0:3],
    input wire signed [15:0] weights [0:3][0:3],
    output wire signed [31:0] results [0:3]
);

inner_product_4x16 ipu0 (
    .clk(clk),
    .reset(reset),
    .enable(enable),
    .activations(activations),
    .weights(weights[0]),
    .result(results[0])
);

inner_product_4x16 ipu1 (
    .clk(clk),
    .reset(reset),
    .enable(enable),
    .activations(activations),
    .weights(weights[1]),
    .result(results[1])
);

inner_product_4x16 ipu2 (
    .clk(clk),
    .reset(reset),
    .enable(enable),
    .activations(activations),
    .weights(weights[2]),
    .result(results[2])
);

inner_product_4x16 ipu3 (
    .clk(clk),
    .reset(reset),
    .enable(enable),
    .activations(activations),
    .weights(weights[3]),
    .result(results[3])
);

endmodule
\end{lstlisting}

在我的设计中，激活值向量通过广播机制同时传递给所有内积运算器，权重矩阵按行分配给各个内积运算器，\texttt{weights[i]}表示第i行。输出结果为\texttt{wire}类型，直接连接到子模块的输出端口。这个运算器继承了内积运算器的两级流水线特性，输出结果延迟2拍产生。

\subsection{矩阵乘法运算器设计}

矩阵乘法运算可以分解为多个矩阵乘向量运算：激活值矩阵的每一行作为一个向量，与权重矩阵进行矩阵乘向量运算，产生输出矩阵的一行。因此，矩阵乘法运算器通过并行实例化4个矩阵乘向量运算器实现。4个矩阵乘向量运算器共享同一个权重矩阵（通过广播机制），分别接收激活值矩阵的不同行，并行产生4行输出结果。

\begin{lstlisting}[language=Verilog]
module matrix_mult_4x4x4x16 (
    input wire clk,
    input wire reset,
    input wire enable,
    input wire signed [15:0] activations [0:3][0:3],
    input wire signed [15:0] weights [0:3][0:3],
    output wire signed [31:0] results [0:3][0:3]
);

matrix_vector_mult_4x4x16 mxv0 (
    .clk(clk),
    .reset(reset),
    .enable(enable),
    .activations(activations[0]),
    .weights(weights),
    .results(results[0])
);

matrix_vector_mult_4x4x16 mxv1 (
    .clk(clk),
    .reset(reset),
    .enable(enable),
    .activations(activations[1]),
    .weights(weights),
    .results(results[1])
);

matrix_vector_mult_4x4x16 mxv2 (
    .clk(clk),
    .reset(reset),
    .enable(enable),
    .activations(activations[2]),
    .weights(weights),
    .results(results[2])
);

matrix_vector_mult_4x4x16 mxv3 (
    .clk(clk),
    .reset(reset),
    .enable(enable),
    .activations(activations[3]),
    .weights(weights),
    .results(results[3])
);

endmodule
\end{lstlisting}

权重矩阵通过广播机制同时传递给所有矩阵乘向量运算器，激活值矩阵按行分配给各个矩阵乘向量运算器，\texttt{activations[i]}表示第i行。整个模块共包含16个内积运算器（4×4），可并行完成16次内积运算。

权重数据仅需读取一次即可参与4个批次的运算，使得运算密度进一步提高。然而，这种设计也存在工程实现上的挑战：随着运算器规模扩大，广播信号的扇出增大、布线距离变长，对电路的时序和功耗提出了更高要求。

\subsection{编译与仿真环境配置}

为了验证设计的正确性，需要编写C++测试文件作为仿真顶层，并配置Makefile进行自动化编译。

Makefile定义了三个编译目标，分别对应三种运算器，每个目标指定了需要编译的Verilog源文件和C++测试文件：

\begin{lstlisting}[language=make]
MODULES = inner_product_4x16 matrix_vector_mult_4x4x16 matrix_mult_4x4x4x16
TEST_FILES = tb_inner_product.cpp tb_matrix_vector.cpp tb_matrix_mult.cpp

VERILATOR = verilator
VERILATOR_FLAGS = --cc --exe --build -Wall --trace -I$(SRC_DIR)

# 内积运算器编译
inner_product_4x16:
	$(VERILATOR) $(VERILATOR_FLAGS) --Mdir $(OBJ_DIR)/$@ \
		$(SRC_DIR)/$@.v \
		tb_inner_product.cpp \
		--top-module $@ \
		-CFLAGS "$(CXXFLAGS)"
\end{lstlisting}

测试文件负责读取数据文件、生成时钟信号、控制复位和使能信号、采集运算结果并与期望值比对。关键功能包括：

\begin{enumerate}
    \item 从二进制格式的数据文件中读取激活值、权重和期望结果。
    \item 生成周期性的时钟信号，控制复位和使能信号的时序。
    \item 在适当的时刻将数据送入运算器，并在流水线延迟后采集结果。
    \item 比对实际结果与期望结果，输出测试状态（PASS/FAIL）。
    \item 可选生成VCD波形文件，用于GTKWave时序分析。
\end{enumerate}

编译完成后，可通过以下命令运行测试：
\begin{lstlisting}[language=bash]
cd sim
make clean
make all
./obj_dir/inner_product_4x16/Vinner_product_4x16 ../data
\end{lstlisting}

\section{实验结果及分析}

\subsection{初步运行结果}

本小节展示使用原始数据目录（\texttt{../data}）对三种运算器进行的初步功能验证。数据文件以16位二进制格式存储，包含神经元激活值（neuron）、权重（weight）和期望结果（result）。

\subsubsection{内积运算器测试结果}

内积运算器测试输入为激活值向量$[1, 2, 3, 4]$和权重向量$[1, 0, 0, 0]$，期望输出结果为1。图\ref{fig:result_inner}展示了终端运行结果，可以看到实际输出结果为1，与期望结果一致，验证通过。

\begin{figure}[H]
\centering
\includegraphics[width=0.65\textwidth]{fig/result_inner.png}
\caption{内积运算器终端测试结果}
\label{fig:result_inner}
\end{figure}

测试过程详细记录了仿真的各个阶段：
\begin{itemize}
    \item 时间0-5：复位阶段，所有寄存器被清零。
    \item 时间9：数据加载，将激活值和权重送入运算器输入端口。
    \item 时间11：使能信号拉高，运算器开始工作。
    \item 时间15：使能信号关闭。
    \item 时间26：捕获结果，此时流水线延迟已过，输出结果稳定。
\end{itemize}

图\ref{fig:wave_inner}展示了GTKWave波形图。从波形中可以清晰地观察到：
\begin{itemize}
    \item \texttt{clk}信号周期性翻转，提供同步时钟。
    \item \texttt{reset}信号在初始阶段为高电平，随后拉低。
    \item \texttt{activations[0:3]}和\texttt{weights[0:3]}在时间9加载数据。
    \item \texttt{activations\_reg[0:3]}和\texttt{weights\_reg[0:3]}在使能信号有效后的第一个时钟上升沿锁存数据。
    \item \texttt{dot\_product}信号立即计算出内积结果（组合逻辑）。
    \item \texttt{result}信号在下一个时钟上升沿输出最终结果（0x00000001，即十进制1）。
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{fig/wave_inner.png}
\caption{内积运算器GTKWave波形图}
\label{fig:wave_inner}
\end{figure}

波形验证了两级流水线的设计：输入寄存器在第一拍锁存数据，输出寄存器在第二拍输出结果，整个流水线延迟为2个时钟周期。

\subsubsection{矩阵乘向量运算器测试结果}

矩阵乘向量运算器测试输入为激活值向量$[1, 2, 3, 4]$和单位权重矩阵：
$$
W = \begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

期望输出结果为$[1, 2, 3, 4]$。图\ref{fig:result_vector}展示了终端运行结果，实际输出的4个结果分别为1、2、3、4，与期望结果完全一致，验证通过。

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{fig/result_vector.png}
\caption{矩阵乘向量运算器终端测试结果}
\label{fig:result_vector}
\end{figure}

图\ref{fig:wave_vector}展示了GTKWave波形图。从波形中可以观察到：
\begin{itemize}
    \item 左侧SST面板显示了模块层次结构：顶层模块\texttt{matrix\_vector\_mult\_4x4x16}包含4个子模块\texttt{ipu0-ipu3}，每个子模块都是一个\texttt{inner\_product\_4x16}实例。
    \item \texttt{activations[0:3]}作为共享输入，广播到所有内积运算器。
    \item \texttt{weights[0:3][0:3]}表示4×4权重矩阵，\texttt{weights\_reg[i]}显示各内积运算器锁存的权重行。
    \item \texttt{results[0:3]}同时输出4个内积结果，分别为0x00000001、0x00000002、0x00000003、0x00000004。
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{fig/wave_vector.png}
\caption{矩阵乘向量运算器GTKWave波形图}
\label{fig:wave_vector}
\end{figure}

波形验证了矩阵乘向量运算器的并行特性：4个内积运算器同时工作，在同一个时钟周期产生4个输出结果。

\subsubsection{矩阵乘法运算器测试结果}

矩阵乘法运算器测试输入为激活值矩阵和权重矩阵均为单位矩阵，期望输出为单位矩阵。图\ref{fig:result_mult}展示了终端运行结果，实际输出的16个结果（4×4矩阵）与期望结果完全一致，所有结果验证通过。

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{fig/result_mult.png}
\caption{矩阵乘法运算器终端测试结果}
\label{fig:result_mult}
\end{figure}

图\ref{fig:wave_mult}展示了GTKWave波形图。从波形中可以观察到：
\begin{itemize}
    \item 左侧SST面板显示了三层模块层次结构：顶层\texttt{matrix\_mult\_4x4x4x16}包含4个\texttt{mxv0-mxv3}（矩阵乘向量运算器），每个mxv又包含4个\texttt{ipu0-ipu3}（内积运算器），总共16个内积运算器并行工作。
    \item \texttt{weights[0:3][0:3]}作为共享输入，广播到所有矩阵乘向量运算器。
    \item \texttt{activations[0:3][0:3]}表示4×4激活值矩阵，按行分配给不同的矩阵乘向量运算器。
    \item \texttt{results[0:3][0:3]}输出4×4结果矩阵，每个元素为32位有符号整数。
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{fig/wave_mult.png}
\caption{矩阵乘法运算器GTKWave波形图}
\label{fig:wave_mult}
\end{figure}

波形验证了矩阵乘法运算器的高度并行特性：16个内积运算器同时工作，一个时钟周期完成4×4矩阵乘法的所有16次内积运算。

\subsection{对更多不同测试数据的验证}

为了更全面地验证三种运算器的功能正确性，我设计了4组不同的测试数据，并编写了\texttt{run\_all\_tests.sh}一键测试脚本。测试数据包括：

\begin{itemize}
    \item \textbf{Test1}：单位矩阵测试，验证基本功能。
    \item \textbf{Test2}：全1矩阵测试，验证累加功能。
    \item \textbf{Test3}：对角缩放测试，验证不同位置的数据处理。
    \item \textbf{Test4}：非对称矩阵测试，验证一般情况下的计算正确性。
\end{itemize}

\textbf{测试脚本实现：}

\begin{lstlisting}[language=bash]
#!/bin/bash

cd "$(dirname "$0")"

echo "========== Deep Learning Processor Test Report =========="
echo ""

# Compile
make clean > /dev/null 2>&1
make all > /dev/null 2>&1

# Test counters
total=0
passed=0

# Test Inner Product
echo "[1] Inner Product (4x16-bit):"
for i in 1 2 3 4; do
    total=$((total + 1))
    echo -n "  Test$i: "
    ./obj_dir/inner_product_4x16/Vinner_product_4x16 ../data/test$i 2>/dev/null
    if [ $? -eq 0 ]; then
        passed=$((passed + 1))
    fi
done

# Test Matrix-Vector
echo "[2] Matrix-Vector Mult (4x4x16-bit):"
for i in 1 2 3 4; do
    total=$((total + 1))
    echo -n "  Test$i: "
    ./obj_dir/matrix_vector_mult_4x4x16/Vmatrix_vector_mult_4x4x16 ../data/test$i 2>/dev/null
    if [ $? -eq 0 ]; then
        passed=$((passed + 1))
    fi
done

# Test Matrix-Matrix
echo "[3] Matrix-Matrix Mult (4x4x4x16-bit):"
for i in 1 2 3 4; do
    total=$((total + 1))
    echo -n "  Test$i: "
    ./obj_dir/matrix_mult_4x4x4x16/Vmatrix_mult_4x4x4x16 ../data/test$i 2>/dev/null
    if [ $? -eq 0 ]; then
        passed=$((passed + 1))
    fi
done

# Summary
echo "=========================================================="
echo "Result: $passed/$total tests passed"
if [ $passed -eq $total ]; then
    echo "Status: ALL PASS"
else
    echo "Status: SOME FAILED"
fi
\end{lstlisting}

脚本自动完成编译、对3种运算器分别运行4组测试数据、统计通过率并输出测试报告。

图\ref{fig:run_all_tests}展示了运行\texttt{run\_all\_tests.sh}脚本的完整输出。可以看到：

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{fig/run_all_tests.png}
\caption{一键测试脚本运行结果}
\label{fig:run_all_tests}
\end{figure}

\begin{enumerate}
    \item \textbf{内积运算器}通过了所有4组测试，包括：
        \begin{itemize}
            \item Test1: $[1,2,3,4] \cdot [1,0,0,0] = 1$
            \item Test2: $[1,1,1,1] \cdot [1,1,1,1] = 4$
            \item Test3: $[1,2,3,4] \cdot [2,0,0,0] = 2$
            \item Test4: $[2,3,1,4] \cdot [1,2,0,0] = 8$
        \end{itemize}
    \item \textbf{矩阵乘向量运算器}通过了所有4组测试，验证了与单位矩阵、全1矩阵、对角矩阵、非对称矩阵的乘法运算。
    \item \textbf{矩阵乘法运算器}通过了所有4组测试，验证了4×4矩阵乘法的完整功能。
    \item 总计12个测试全部通过（12/12），状态显示\texttt{ALL PASS}。
\end{enumerate}

测试结果表明，三种运算器的设计完全正确，能够处理各种不同的输入数据，满足设计要求。

\section{实验过程中遇到的问题}

\subsection{Verilator编译环境配置问题}

在Ubuntu系统上初次安装Verilator时，执行\texttt{make}命令时报错，提示缺少\texttt{flex}和\texttt{bison}等依赖库。发现问题后，我参照讲义第8.3.1节的安装指南，系统地安装了必需的依赖包。虽然在安装过程中出现少许报错，但重新编译Verilator成功。

\subsection{模块实例化端口连接问题}

在实现矩阵乘向量运算器时，初次尝试实例化内积运算器，遇到端口连接错误。对于数组类型的端口（如\texttt{weights[0:3][0:3]}），我不确定如何将二维数组的某一行连接到子模块。查阅资料后得知，Verilog支持数组切片语法，可以直接使用\texttt{weights[i]}表示二维数组的第i行。正确的连接方式为：

\begin{lstlisting}[language=Verilog]
inner_product_4x16 ipu0 (
    .activations(activations),
    .weights(weights[0]),  // 连接权重矩阵的第0行
    .result(results[0])
);
\end{lstlisting}

\section{对思考题的回答}

\subsection{运算器资源对比与规模分析}

\subsubsection*{题目}

对比分析内积运算器、矩阵乘向量运算器和矩阵乘法运算器内部的乘法器数量、加法器数量和对外数据接口数量，计算并对比每种设计中这些元素的比例。如果增大三种运算器的规模（例如，向量长度从4增加到16乃至128），这些设计的比例分别会发生什么样的变化？

\subsubsection*{解答}

假设向量长度为$n$（本实验中$n=4$），三种运算器的乘法器数量分别为$n$、$n^2$、$n^3$，加法器数量分别为$n-1$、$n(n-1)$、$n^2(n-1)$。在数据接口方面，内积运算器需要$2n$个16位输入和1个32位输出，总接口位宽为$32n+32$位；矩阵乘向量运算器需要$n+n^2$个16位输入和$n$个32位输出，总接口位宽为$16n(n+3)$位；矩阵乘法运算器需要$2n^2$个16位输入和$n^2$个32位输出，总接口位宽为$64n^2$位。

定义运算密度$\rho = \frac{\text{乘法器数量}}{\text{总接口位宽}}$来衡量单位数据接口的运算能力。在$n=4$时，三种运算器的运算密度分别为0.025、0.036、0.063，矩阵乘法运算器是内积运算器的2.5倍。通过数学推导可得，内积运算器的运算密度$\rho_{inner} = \frac{n}{32(n+1)} \approx 1/32$（$n$较大时），矩阵乘向量运算器的运算密度$\rho_{mv} = \frac{n}{16(n+3)} \approx 1/16$，而矩阵乘法运算器的运算密度$\rho_{mm} = \frac{n}{64}$与$n$成正比。

当向量长度从4增加到128时，内积和矩阵乘向量运算器的运算密度几乎不变，而矩阵乘法运算器的运算密度从0.063提升到2.0，增长了32倍。这意味着在大规模运算中，矩阵乘法运算器每位数据接口可支持2个乘法运算，充分体现了其在大规模神经网络中的巨大优势。实际工程中需要在运算密度和布线时序等挑战之间平衡，现代DLP芯片通常采用16×16到32×32的矩阵乘法单元。

\subsection{深度学习处理器加速原理}

\subsubsection*{题目}

请说明深度学习处理器加速深度学习计算的基本原理是什么？

\subsubsection*{解答}

深度学习处理器加速的核心在于采用矩阵运算作为基本算子。传统CPU和GPU使用标量或向量运算，执行矩阵运算时需要多次访存和发射指令，运算密度低。而DLP将矩阵乘向量、矩阵乘法作为基本算子，一个时钟周期即可完成数十乃至数百次乘加操作，如本实验的矩阵乘法运算器一个周期完成64次乘法和48次加法。

数据复用是另一关键机制。在矩阵乘向量运算中，激活值向量被所有内积运算器共享，仅需读取一次；在矩阵乘法运算中，权重矩阵进一步被所有矩阵乘向量运算器共享，总体数据复用率可达16倍。这显著降低了对存储器访问带宽的需求，突破了深度学习运算中的“Memory Wall”瓶颈。DLP还配备专用的便笺存储器暂存数据（如讲义中的图8.1），通过DMA将主存访问与运算流水化。

此外，DLP采用大规模并行计算（数百个运算单元同时工作）、低精度数据格式（INT8/INT16降低面积和功耗）、以及针对深度学习算法特征的定制化设计，去除通用处理器中不必要的控制逻辑。通过这些综合设计，DLP在深度学习任务上相比通用处理器实现了数十倍乃至数百倍的性能和能效优势，这正是Google TPU、NVIDIA Tensor Core、华为昇腾等AI芯片的核心设计思想。

\section{实验总结与心得感想}

通过实验，我深刻体会到深度学习处理器采用矩阵运算作为基本算子的优越性。相比于传统CPU、GPU采用的标量、向量运算，矩阵运算具有更高的运算密度。这种优势体现在两个方面：

首先是\textbf{数据复用}。在矩阵乘向量运算中，激活值向量被4个内积运算器共享，仅需读取一次即可参与4次内积运算；在矩阵乘法运算中，权重矩阵被4个矩阵乘向量运算器共享，数据复用程度进一步提高。这种设计显著降低了对便笺存储器访问带宽的需求，使得在同等访存能力下能够达到更高的算力。

其次是\textbf{并行度}。内积运算器包含4个并行乘法器，矩阵乘向量运算器包含4个并行内积运算器（16个乘法器），矩阵乘法运算器包含16个并行内积运算器（64个乘法器）。这种层次化并行结构使得大规模矩阵运算能够在极短时间内完成。以本实验实现的矩阵乘法运算器为例，每个时钟周期可完成16次内积运算，相当于64次乘法和48次加法，这在传统标量处理器上需要数十甚至上百个时钟周期才能完成。

展望未来，我希望能够在本实验的基础上进行更深入的探索。例如，可以尝试扩大运算器规模，从4×4扩展到16×16甚至更大；可以尝试实现更复杂的数据格式，如浮点数或低比特量化；可以尝试优化电路性能，如增加流水线级数、采用Wallace树加法器等。更进一步，可以将运算器部署到FPGA上进行实际测试，体验硬件加速的真实效果。

最后，衷心感谢讲义提供的详细指导和实验框架，也感谢老师和助教的悉心指导！

\end{document}